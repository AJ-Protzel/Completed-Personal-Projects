import csv
import sqlite3
import os

# Define the data folder path
data_folder_path = "data"

# Define the database file name
database_file = "main.db"

# Connect to the database
connection = sqlite3.connect(database_file)
cursor = connection.cursor()

# Create the table "transactions" if it doesn't exist (adjust column names if needed)
create_table_query = """
CREATE TABLE IF NOT EXISTS transactions (
    date TEXT,
    description TEXT,
    amount REAL
)
"""
cursor.execute(create_table_query)

# Get list of files in the data folder
data_files = os.listdir(data_folder_path)

# Loop through each file in the data folder
for filename in data_files:
    # Skip non-CSV files (optional, adjust based on your needs)
    if not filename.endswith(".csv"):
        continue

    # Construct the full path to the CSV file
    csv_file_path = os.path.join(data_folder_path, filename)

    # Open the CSV file
    with open(csv_file_path, "r") as csvfile:
        csv_reader = csv.reader(csvfile)
        next(csv_reader)  # Skip header row

        for row in csv_reader:
            try:
                amount = float(row[2])
            except ValueError:
                print(f"Error: Could not convert amount '{row[2]}' to a number for row: {row}")
                continue

            insert_query = """
            INSERT INTO transactions (date, description, amount)
            VALUES (?, ?, ?)
            """
            cursor.execute(insert_query, (row[0], row[1], amount))

# Commit changes and close connection
connection.commit()
connection.close()

print("Success")














import csv
import sqlite3
import os

# Define the data folder path
data_folder_path = "data"

# Define the database file name
database_file = "main.db"

# Connect to the database
connection = sqlite3.connect(database_file)
cursor = connection.cursor()

# Create the table "transactions" if it doesn't exist (adjust column names if needed)
create_table_query = """
CREATE TABLE IF NOT EXISTS transactions (
    date TEXT,
    description TEXT,
    amount REAL,
)
"""
cursor.execute(create_table_query)

# Get list of files in the data folder
data_files = os.listdir(data_folder_path)

# Loop through each file in the data folder
for filename in data_files:
    # Skip non-CSV files (optional, adjust based on your needs)
    if not filename.endswith(".csv"):
        continue

    # Construct the full path to the CSV file
    csv_file_path = os.path.join(data_folder_path, filename)

    # Open the CSV file
    with open(csv_file_path, "r") as csvfile:
        csv_reader = csv.reader(csvfile)
        next(csv_reader)  # Skip header row

        for row in csv_reader:
            try:
                # amount = float(row[2])
                amount = float(row[2].replace(",", "").strip())  # Strip leading/trailing spaces

            except ValueError:
                print(f"Error: Could not convert amount '{row[2]}' to a number for row: {row}")
                continue

            insert_query = """
            INSERT INTO transactions (date, description, amount)
            VALUES (?, ?, ?)
            """
            cursor.execute(insert_query, (row[0], row[1], amount))

# Commit changes and close connection
connection.commit()
connection.close()

print("Success")















import csv
import sqlite3
import datetime
import os

def remove_duplicate_records(cursor):
  
  """
  This function removes duplicate records from the 'transactions' table.

  Args:
      cursor (sqlite3.Cursor): The database cursor object.
  """
  # Define a query to identify duplicates using a subquery
  deduplication_query = """
    DELETE FROM transactions AS t1
    WHERE EXISTS (
      SELECT 1
      FROM transactions AS t2
      WHERE t1.year = t2.year
        AND t1.month = t2.month
        AND t1.date = t2.date
        AND t1.description = t2.description
        AND t1.amount = t2.amount
        AND t1.rowid > t2.rowid
    );
  """
  cursor.execute(deduplication_query)

# Define the data folder path
data_folder_path = "data"

# Define the database file name
database_file = "main.db"

# Connect to the database
connection = sqlite3.connect(database_file)
cursor = connection.cursor()

# Create the table "transactions" if it doesn't exist (adjust column names if needed)
create_table_query = """
CREATE TABLE IF NOT EXISTS transactions (
  year INTEGER,
  month TEXT,
  date TEXT,
  description TEXT,
  amount REAL
)
"""
cursor.execute(create_table_query)  # Might raise an error if table already exists

# Get list of files in the data folder
data_files = os.listdir(data_folder_path)

# Loop through each file in the data folder
for filename in data_files:
  # Skip non-CSV files (optional, adjust based on your needs)
  if not filename.endswith(".csv"):
    continue

  # Construct the full path to the CSV file
  csv_file_path = os.path.join(data_folder_path, filename)

  # Open the CSV file
  with open(csv_file_path, "r") as csvfile:
    csv_reader = csv.reader(csvfile)
    next(csv_reader)  # Skip header row

    for row in csv_reader:
      try:
        # Handle comma (,) as decimal separator (adjust if needed)
        amount = float(row[2].strip().replace(",", ""))  # Remove spaces and replace comma

        # Extract date parts using datetime
        date_str = row[0]  # Assuming date is in the first column (adjust index if needed)
        date_obj = datetime.datetime.strptime(date_str, "%m/%d/%Y")  # Parse in M-D-Y format

        # Get month as a word and year
        month_name = date_obj.strftime("%B")  # Full month name (e.g., January)
        year = date_obj.year

        # Update the insert query with reordered columns
        insert_query = """
          INSERT INTO transactions (year, month, date, description, amount)
          VALUES (?, ?, ?, ?, ?)
        """
        cursor.execute(insert_query, (year, month_name, date_str, row[1], amount))

      except ValueError as error:
        # Handle potential conversion errors
        print(f"Error: Could not process data for row: {row}. Original error: {error}")
        continue

# Call the function after data insertion
remove_duplicate_records(cursor)

# Commit changes and close connection
connection.commit()
connection.close()

print("Success")
















import csv
import sqlite3
import datetime
import os

def remove_duplicate_records(cursor):
  
  """
  This function removes duplicate records from the 'transactions' table.

  Args:
      cursor (sqlite3.Cursor): The database cursor object.
  """
  # Define a query to identify duplicates using a subquery
  deduplication_query = """
    DELETE FROM transactions AS t1
    WHERE EXISTS (
      SELECT 1
      FROM transactions AS t2
      WHERE t1.year = t2.year
        AND t1.month = t2.month
        AND t1.date = t2.date
        AND t1.description = t2.description
        AND t1.amount = t2.amount
        AND t1.rowid > t2.rowid
    );
  """
  cursor.execute(deduplication_query)

# Define the data folder path
data_folder_path = "data"

# Define the database file name
database_file = "main.db"

# Connect to the database
connection = sqlite3.connect(database_file)
cursor = connection.cursor()

# Create the table "transactions" if it doesn't exist (adjust column names if needed)
create_table_query = """
CREATE TABLE IF NOT EXISTS transactions (
  year INTEGER,
  month TEXT,
  date TEXT,
  description TEXT,
  amount REAL
)
"""
cursor.execute(create_table_query)  # Might raise an error if table already exists

# Get list of files in the data folder
data_files = os.listdir(data_folder_path)

# Loop through each file in the data folder
for filename in data_files:
  # Skip non-CSV files (optional, adjust based on your needs)
  if not filename.endswith(".csv"):
    continue

  # Construct the full path to the CSV file
  csv_file_path = os.path.join(data_folder_path, filename)

  # Open the CSV file
  with open(csv_file_path, "r") as csvfile:
    csv_reader = csv.reader(csvfile)
    next(csv_reader)  # Skip header row

    for row in csv_reader:
      try:
        # Handle comma (,) as decimal separator (adjust if needed)
        amount = float(row[2].strip().replace(",", ""))  # Remove spaces and replace comma

        # Extract date parts using datetime
        date_str = row[0]  # Assuming date is in the first column (adjust index if needed)
        date_obj = datetime.datetime.strptime(date_str, "%m/%d/%Y")  # Parse in M-D-Y format

        # Get month as a word and year
        month_name = date_obj.strftime("%B")  # Full month name (e.g., January)
        year = date_obj.year

        # Update the insert query with reordered columns
        insert_query = """
          INSERT INTO transactions (year, month, date, description, amount)
          VALUES (?, ?, ?, ?, ?)
        """
        cursor.execute(insert_query, (year, month_name, date_str, row[1], amount))

      except ValueError as error:
        # Handle potential conversion errors
        print(f"Error: Could not process data for row: {row}. Original error: {error}")
        continue

# Call the function after data insertion
remove_duplicate_records(cursor)

# Commit changes and close connection
connection.commit()
connection.close()

print("Success")
















import csv
import sqlite3
import datetime
import os

########################################################################################## create_table
def create_table(cursor):
  """
  This function creates the 'transactions' table in the database if it doesn't exist.

  Args:
    cursor (sqlite3.Cursor): The database cursor object.
  """
  create_table_query = """
    CREATE TABLE IF NOT EXISTS transactions (
      year INTEGER,
      month TEXT,
      date TEXT,
      description TEXT,
      amount REAL
    )
  """
  cursor.execute(create_table_query)

##################################################################################### check_file_format
def check_file_format(data_folder_path, filename, expected_columns):
  """
  Checks if the CSV file has the same columns as the target table.

  Args:
      data_folder_path (str): Path to the data folder.
      filename (str): Name of the file to check.
      expected_columns (list): List of expected column names in the table.

  Returns:
      bool: True if the file has the expected columns, False otherwise.
  """
  csv_file_path = os.path.join(data_folder_path, filename)
  try:
    with open(csv_file_path, "r") as csvfile:
      reader = csv.reader(csvfile)
      # Check if header row exists and matches expected columns
      header_row = next(reader, None)
      if header_row is None:
        print(f"Error: File {filename} is missing a header row.")
        return False
      return header_row == expected_columns
  except FileNotFoundError:
    print(f"Error: File not found: {csv_file_path}")
    return False
  except Exception as e:
    print(f"Error: Unexpected error while checking file format: {e}")
    return False
  
########################################################################################### file_reader
def file_reader(cursor, data_folder_path, data_files, expected_columns):
  """
  Reads and processes data from CSV files in the specified folder,
  skipping files with mismatched column names.

  Args:
      cursor (object): Database cursor object.
      data_folder_path (str): Path to the data folder.
      data_files (list): List of file names within the data folder.
      expected_columns (list): List of expected column names in the table.
  """
  for filename in data_files:
    if not check_file_format(data_folder_path, filename, expected_columns):
      print(f"Skipping file: {filename}")
      continue

    csv_file_path = os.path.join(data_folder_path, filename)

    try:
      with open(csv_file_path, "r") as csvfile:
        csv_reader = csv.reader(csvfile)
        next(csv_reader)  # Skip header row

        for row in csv_reader:
          try:
            # Handle comma (,) as decimal separator (adjust if needed)
            amount = float(row[2].strip().replace(",", ""))

            # Extract date parts using datetime
            date_str = row[0]  # Assuming date is in the first column
            date_obj = datetime.datetime.strptime(date_str, "%m/%d/%Y")

            # Get month as a word and year
            month_name = date_obj.strftime("%B")
            year = date_obj.year

            # Update the insert query with reordered columns
            insert_query = """
              INSERT INTO transactions (year, month, date, description, amount)
              VALUES (?, ?, ?, ?, ?)
            """
            cursor.execute(insert_query, (year, month_name, date_str, row[1], amount))

          except ValueError as error:
            print(f"Error: Could not process data for row: {row}. Original error: {error}")
            continue

    except FileNotFoundError:
      print(f"Error: File not found: {csv_file_path}")

############################################################################## remove_duplicate_records
def remove_duplicate_records(cursor):
    """
    This function removes duplicate records from the 'transactions' table.

    Args:
        cursor (sqlite3.Cursor): The database cursor object.
    """
    # Define a query to identify duplicates using a subquery
    deduplication_query = """
        DELETE FROM transactions AS t1
        WHERE EXISTS (
            SELECT 1
            FROM transactions AS t2
            WHERE t1.year = t2.year
                AND t1.month = t2.month
                AND t1.date = t2.date
                AND t1.description = t2.description
                AND t1.amount = t2.amount
                AND t1.rowid > t2.rowid
        );
    """
    cursor.execute(deduplication_query)

#######################################################################################################
################################################################################################## Main
#######################################################################################################
def main():
    # Define the data folder path
    data_folder_path = "data"

    # Define the database file name
    database_file = "main.db"

    # Connect to the database
    connection = sqlite3.connect(database_file)
    cursor = connection.cursor()

    # Create the table
    create_table(cursor)

    # Get list of files in the data folder
    data_files = os.listdir(data_folder_path)

    # read in lines of all files in data folder
    # file_reader(cursor, data_folder_path, data_files)

    expected_columns = ["Date", "Description", "Amount"]
    file_reader(cursor, data_folder_path, data_files, expected_columns)

    # Call the function after data insertion
    remove_duplicate_records(cursor)

    # Commit changes and close connection
    connection.commit()
    connection.close()

    print("Success")

if __name__ == "__main__":
  main()




























import csv
import sqlite3
import os

MONTHS = {
    1: "January",
    2: "February",
    3: "March",
    4: "April",
    5: "May",
    6: "June",
    7: "July",
    8: "August",
    9: "September",
    10: "October",
    11: "November",
    12: "December"
}

######################################################################################### load_mappings
def load_mappings(file_path):
  mapping = {}
  with open(file_path, 'r') as file:
    for line in file:
      key, value = line.strip().split('=')
      mapping[key] = value
  return mapping

description_mapping = load_mappings("description_mapping.txt")
category_mapping = load_mappings("category_mapping.txt")

########################################################################################## create_table
def create_table(cursor):
  create_table_query = """
    CREATE TABLE IF NOT EXISTS transactions (
      year INTEGER,
      month TEXT,
      date TEXT,
      description TEXT,
      amount REAL,
      category TEXT,
      bank TEXT,
      account TEXT
    )
  """
  cursor.execute(create_table_query)

############################################################################################ read_files
def read_files(cursor, data_folder_path):
    for file in os.listdir(data_folder_path):
        csv_map = {
            "bofa credit.csv": fill_table_bofa_credit,
            "bofa savings.csv": fill_table_bofa_savings,
            "chase credit.csv": fill_table_chase_credit,
        }

        if file in csv_map:
            print(f"Processing: {file}")
            csv_map[file](cursor, os.path.join(data_folder_path, file))
        else:
            print(f"Error: {file} Function Not Found")

################################################################################ fill_table_bofa_credit
def fill_table_bofa_credit(cursor, file_path):
  with open(file_path, 'r') as file:
      reader = csv.reader(file)
      next(reader)

      for row in reader:
          month, day, year = row[0].split('/')
          month = MONTHS.get(int(month))
          date = str(row[0])
          description = description_mapping.get(row[2])
          amount = row[4]
          category = category_mapping.get(row[2])

          insert_query = """
              INSERT INTO transactions (year, month, date, description, amount, category, bank, account)
              VALUES (?, ?, ?, ?, ?, ?, "BofA", "Credit")  
          """
          cursor.execute(insert_query, (year, month, date, description, amount, category))

  cursor.connection.commit()
   
############################################################################### fill_table_bofa_savings
def fill_table_bofa_savings(cursor, file_path):
  print()

############################################################################### fill_table_chase_credit
def fill_table_chase_credit(cursor, file_path):
  print()

###################################################################################### remove_duplicate
def remove_duplicate(cursor):
    deduplication_query = """
        DELETE FROM transactions AS t1
        WHERE EXISTS (
            SELECT 1
            FROM transactions AS t2
            WHERE t1.year = t2.year
                AND t1.month = t2.month
                AND t1.date = t2.date
                AND t1.description = t2.description
                AND t1.amount = t2.amount
                AND t1.category = t2.category
                AND t1.bank = t2.bank
                AND t1.account = t2.account
                AND t1.rowid > t2.rowid
        );
    """
    cursor.execute(deduplication_query)

#######################################################################################################
################################################################################################## Main
#######################################################################################################
def main():
    data_folder_path = "data"
    database_file = "main.db"
    connection = sqlite3.connect(database_file)
    cursor = connection.cursor()

    create_table(cursor)
    read_files(cursor, data_folder_path)
    remove_duplicate(cursor)

    connection.commit()
    connection.close()

    print("Success")

if __name__ == "__main__":
  main()